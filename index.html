<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Piano Minimalista</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        h1 {
            font-weight: 300;
            font-size: 2.5em;
            color: #333;
            margin-bottom: 30px;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 10px 20px;
            border: 2px solid #333;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 300;
            border-radius: 5px;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #333;
            color: white;
        }
        
        button.active {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }
        
        .piano-container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .piano {
            position: relative;
            display: flex;
            gap: 0;
        }
        
        .white-key {
            width: 70px;
            height: 280px;
            border: 2px solid #222;
            background: white;
            cursor: pointer;
            position: relative;
            transition: background 0.1s;
            user-select: none;
        }
        
        .white-key:hover {
            background: #f9f9f9;
        }
        
        .white-key.active {
            background: #ddd;
        }
        
        .white-key.configuring {
            background: #ffe082;
            animation: pulse 0.8s infinite;
        }
        
        .white-key .note {
            position: absolute;
            bottom: 35px;
            width: 100%;
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            color: #333;
        }
        
        .white-key .key-label {
            position: absolute;
            bottom: 4px;
            width: 100%;
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            color: #666;
            text-transform: uppercase;
        }
        
        .black-keys {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .black-key {
            width: 45px;
            height: 175px;
            background: #000;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            position: absolute;
            pointer-events: auto;
            transition: background 0.1s;
            user-select: none;
        }
        
        .black-key:hover {
            background: #333;
        }
        
        .black-key.active {
            background: #555;
        }
        
        .black-key.configuring {
            background: #ffb300;
            animation: pulse 0.8s infinite;
        }
        
        .black-key .note {
            position: absolute;
            bottom: 35px;
            width: 100%;
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            color: white;
        }
        
        .black-key .key-label {
            position: absolute;
            bottom: 4px;
            width: 100%;
            text-align: center;
            font-size: 20px;
            font-weight: 700;
            color: #ccc;
            text-transform: uppercase;
        }
        
        .instructions {
            margin-top: 25px;
            font-size: 14px;
            color: #666;
            font-weight: 300;
            text-align: center;
            max-width: 600px;
        }
        
        .config-message {
            margin-top: 15px;
            padding: 15px;
            background: #ffe082;
            border-radius: 5px;
            font-size: 14px;
            color: #333;
            font-weight: 500;
            display: none;
        }
        
        .config-message.show {
            display: block;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <h1>Piano Minimalista</h1>
    
    <div class="controls">
        <button id="configBtn">‚öôÔ∏è Configurar Teclas</button>
        <button id="resetBtn">üîÑ Restablecer</button>
    </div>
    
    <div class="piano-container">
        <div class="piano" id="piano">
            <!-- Teclas blancas -->
        </div>
        <div class="black-keys" id="blackKeys">
            <!-- Teclas negras -->
        </div>
    </div>
    
    <div class="config-message" id="configMessage">
        Haz clic en una tecla del piano, luego presiona la tecla de tu teclado que quieres asignarle
    </div>
    
    <p class="instructions" id="instructions">
        Usa las teclas de tu teclado: a-s-d-f-g-h-j-k-l-√±-{-}-4-5-6 (blancas) | w-e-t-y-u-i-o-p-'-+ (negras)
    </p>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Crear reverberaci√≥n para dar profundidad al sonido
        const convolver = audioContext.createConvolver();
        const reverbGain = audioContext.createGain();
        reverbGain.gain.value = 0.15; // Reverberaci√≥n sutil
        
        // Crear impulso de reverberaci√≥n simple
        const reverbTime = 1.5;
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * reverbTime;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        convolver.buffer = impulse;
        convolver.connect(reverbGain);
        reverbGain.connect(audioContext.destination);
        
        const oscillators = {};
        const pressedKeys = new Set();
        let configMode = false;
        let selectedKeyIndex = null;
        let selectedKeyType = null;

        const defaultWhiteKeys = [
            { note: 'Do', key: 'a', freq: 261.63 },
            { note: 'Re', key: 's', freq: 293.66 },
            { note: 'Mi', key: 'd', freq: 329.63 },
            { note: 'Fa', key: 'f', freq: 349.23 },
            { note: 'Sol', key: 'g', freq: 392.00 },
            { note: 'La', key: 'h', freq: 440.00 },
            { note: 'Si', key: 'j', freq: 493.88 },
            { note: 'Do', key: 'k', freq: 523.25 },
            { note: 'Re', key: 'l', freq: 587.33 },
            { note: 'Mi', key: '√±', freq: 659.25 },
            { note: 'Fa', key: '{', freq: 698.46 },
            { note: 'Sol', key: '}', freq: 783.99 },
            { note: 'La', key: '4', freq: 880.00 },
            { note: 'Si', key: '5', freq: 987.77 },
            { note: 'Do', key: '6', freq: 1046.50 },
        ];

        const defaultBlackKeys = [
            { note: 'Di', key: 'w', freq: 277.18, position: 0.5 },
            { note: 'Ri', key: 'e', freq: 311.13, position: 1.5 },
            { note: 'Fi', key: 't', freq: 369.99, position: 3.5 },
            { note: 'Sil', key: 'y', freq: 415.30, position: 4.5 },
            { note: 'Li', key: 'u', freq: 466.16, position: 5.5 },
            { note: 'Di', key: 'i', freq: 554.37, position: 7.5 },
            { note: 'Ri', key: 'o', freq: 622.25, position: 8.5 },
            { note: 'Fi', key: 'p', freq: 739.99, position: 10.5 },
            { note: 'Sil', key: "'", freq: 830.61, position: 11.5 },
            { note: 'Li', key: '+', freq: 932.33, position: 12.5 },
        ];

        let whiteKeys = JSON.parse(localStorage.getItem('whiteKeys')) || [...defaultWhiteKeys];
        let blackKeys = JSON.parse(localStorage.getItem('blackKeys')) || [...defaultBlackKeys];

        function saveConfig() {
            localStorage.setItem('whiteKeys', JSON.stringify(whiteKeys));
            localStorage.setItem('blackKeys', JSON.stringify(blackKeys));
        }

        function playNote(key, freq) {
            // Si la nota ya est√° sonando, detenerla completamente primero
            if (oscillators[key]) {
                const oldOscData = oscillators[key];
                
                // Cancelar timeout pendiente si existe
                if (oldOscData.timeoutId) {
                    clearTimeout(oldOscData.timeoutId);
                }
                
                // Detener osciladores inmediatamente
                oldOscData.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                oldOscData.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                
                oldOscData.oscillators.forEach(osc => {
                    try { 
                        osc.stop(audioContext.currentTime);
                    } catch(e) {}
                });
                
                delete oscillators[key];
            }

            const ctx = audioContext;
            const now = ctx.currentTime;
            
            // Crear nodo de ganancia principal con ADSR
            const mainGain = ctx.createGain();
            
            // ADSR Envelope para piano realista
            const attackTime = 0.002;  // Ataque muy r√°pido (martillo golpea)
            const decayTime = 0.3;     // Decaimiento medio
            const sustainLevel = 0.4;  // Nivel de sostenido (40%)
            const peakLevel = 0.5;     // Volumen m√°ximo inicial
            
            // Configurar ADSR
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(peakLevel, now + attackTime);
            mainGain.gain.exponentialRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
            
            // Crear osciladores para arm√≥nicos (sonido m√°s rico)
            const oscillators_array = [];
            
            // Oscilador fundamental (principal)
            const osc1 = ctx.createOscillator();
            osc1.type = 'triangle'; // M√°s suave que sine
            osc1.frequency.setValueAtTime(freq, now);
            const gain1 = ctx.createGain();
            gain1.gain.value = 1.0;
            osc1.connect(gain1);
            gain1.connect(mainGain);
            oscillators_array.push(osc1);
            
            // Segundo arm√≥nico (octava arriba, m√°s sutil)
            const osc2 = ctx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(freq * 2, now);
            const gain2 = ctx.createGain();
            gain2.gain.value = 0.15; // M√°s sutil
            osc2.connect(gain2);
            gain2.connect(mainGain);
            oscillators_array.push(osc2);
            
            // Tercer arm√≥nico (quinta arriba)
            const osc3 = ctx.createOscillator();
            osc3.type = 'sine';
            osc3.frequency.setValueAtTime(freq * 3, now);
            const gain3 = ctx.createGain();
            gain3.gain.value = 0.08;
            osc3.connect(gain3);
            gain3.connect(mainGain);
            oscillators_array.push(osc3);
            
            // Conectar a destino y reverberaci√≥n
            mainGain.connect(ctx.destination);
            mainGain.connect(convolver);
            
            // Iniciar todos los osciladores
            oscillators_array.forEach(osc => osc.start(now));
            
            oscillators[key] = { 
                oscillators: oscillators_array, 
                gainNode: mainGain,
                timeoutId: null
            };
        }

        function stopNote(key) {
            const oscData = oscillators[key];
            if (!oscData) return;

            const { oscillators: oscs, gainNode } = oscData;
            const ctx = audioContext;
            const now = ctx.currentTime;
            
            // Release: desvanecimiento suave del piano
            const releaseTime = 0.5;
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);
            
            const timeoutId = setTimeout(() => {
                // Solo limpiar si este es todav√≠a el oscilador activo para esta tecla
                if (oscillators[key] && oscillators[key].timeoutId === timeoutId) {
                    oscs.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    delete oscillators[key];
                }
            }, releaseTime * 1000 + 100);
            
            oscData.timeoutId = timeoutId;
        }

        function handleKeyDown(key) {
            if (configMode) return;
            if (pressedKeys.has(key)) return;
            pressedKeys.add(key);
            
            const keyElement = document.querySelector(`[data-key="${key}"]`);
            if (keyElement) {
                keyElement.classList.add('active');
            }
            
            const allKeys = [...whiteKeys, ...blackKeys];
            const keyData = allKeys.find(k => k.key === key);
            if (keyData) {
                playNote(key, keyData.freq);
            }
        }

        function handleKeyUp(key) {
            if (configMode) return;
            pressedKeys.delete(key);
            
            const keyElement = document.querySelector(`[data-key="${key}"]`);
            if (keyElement) {
                keyElement.classList.remove('active');
            }
            
            stopNote(key);
        }

        function renderPiano() {
            const pianoDiv = document.getElementById('piano');
            const blackKeysDiv = document.getElementById('blackKeys');
            
            pianoDiv.innerHTML = '';
            blackKeysDiv.innerHTML = '';

            whiteKeys.forEach((keyData, idx) => {
                const keyDiv = document.createElement('div');
                keyDiv.className = 'white-key';
                keyDiv.dataset.key = keyData.key;
                keyDiv.dataset.index = idx;
                keyDiv.dataset.type = 'white';
                keyDiv.innerHTML = `
                    <div class="note">${keyData.note}</div>
                    <div class="key-label">${keyData.key}</div>
                `;
                
                keyDiv.addEventListener('mousedown', (e) => {
                    if (configMode) {
                        selectKeyForConfig(idx, 'white');
                    } else {
                        handleKeyDown(keyData.key);
                    }
                });
                keyDiv.addEventListener('mouseup', () => !configMode && handleKeyUp(keyData.key));
                keyDiv.addEventListener('mouseleave', () => !configMode && handleKeyUp(keyData.key));
                
                pianoDiv.appendChild(keyDiv);
            });

            blackKeys.forEach((keyData, idx) => {
                const keyDiv = document.createElement('div');
                keyDiv.className = 'black-key';
                keyDiv.dataset.key = keyData.key;
                keyDiv.dataset.index = idx;
                keyDiv.dataset.type = 'black';
                keyDiv.style.left = `${52.5 + keyData.position * 70}px`;
                keyDiv.innerHTML = `
                    <div class="note">${keyData.note}</div>
                    <div class="key-label">${keyData.key}</div>
                `;
                
                keyDiv.addEventListener('mousedown', (e) => {
                    if (configMode) {
                        selectKeyForConfig(idx, 'black');
                    } else {
                        handleKeyDown(keyData.key);
                    }
                });
                keyDiv.addEventListener('mouseup', () => !configMode && handleKeyUp(keyData.key));
                keyDiv.addEventListener('mouseleave', () => !configMode && handleKeyUp(keyData.key));
                
                blackKeysDiv.appendChild(keyDiv);
            });
        }

        function selectKeyForConfig(index, type) {
            document.querySelectorAll('.configuring').forEach(el => {
                el.classList.remove('configuring');
            });

            selectedKeyIndex = index;
            selectedKeyType = type;

            const keyElement = document.querySelector(`[data-index="${index}"][data-type="${type}"]`);
            if (keyElement) {
                keyElement.classList.add('configuring');
            }
        }

        function toggleConfigMode() {
            configMode = !configMode;
            const configBtn = document.getElementById('configBtn');
            const configMessage = document.getElementById('configMessage');
            
            if (configMode) {
                configBtn.classList.add('active');
                configBtn.textContent = '‚úì Configurando...';
                configMessage.classList.add('show');
            } else {
                configBtn.classList.remove('active');
                configBtn.textContent = '‚öôÔ∏è Configurar Teclas';
                configMessage.classList.remove('show');
                document.querySelectorAll('.configuring').forEach(el => {
                    el.classList.remove('configuring');
                });
                selectedKeyIndex = null;
                selectedKeyType = null;
            }
        }

        function resetToDefault() {
            if (confirm('¬øRestaurar la configuraci√≥n original del teclado?')) {
                whiteKeys = [...defaultWhiteKeys];
                blackKeys = [...defaultBlackKeys];
                saveConfig();
                renderPiano();
            }
        }

        document.getElementById('configBtn').addEventListener('click', toggleConfigMode);
        document.getElementById('resetBtn').addEventListener('click', resetToDefault);

        window.addEventListener('keydown', (e) => {
            if (configMode && selectedKeyIndex !== null) {
                e.preventDefault();
                const newKey = e.key.toLowerCase();
                
                if (selectedKeyType === 'white') {
                    whiteKeys[selectedKeyIndex].key = newKey;
                } else {
                    blackKeys[selectedKeyIndex].key = newKey;
                }
                
                saveConfig();
                renderPiano();
                
                document.querySelectorAll('.configuring').forEach(el => {
                    el.classList.remove('configuring');
                });
                selectedKeyIndex = null;
                selectedKeyType = null;
            } else {
                handleKeyDown(e.key.toLowerCase());
            }
        });

        window.addEventListener('keyup', (e) => {
            handleKeyUp(e.key.toLowerCase());
        });

        renderPiano();
    </script>
</body>
</html>
